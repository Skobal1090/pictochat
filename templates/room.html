    <!DOCTYPE html>
    <html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <style> canvas{border: 1px solid black} </style>
        <title>{{ title }}</title>
    </head>
    <body>
        <h1>{{ heading }}</h1>
        <button id="clearDrawing" style="visibility: hidden;">Clear</button>
        <canvas onmousemove="draw(event)" id="drawableCanvas" width="400" height="250" style="visibility: hidden;"></canvas>
        <input type="text" id="messageInput" placeholder="Type your message">
        <button id="drawButton">Draw</button>
        <button id="sendButton">Send</button>
        <a href="../" ><button id="leaveButton">Leave Room</button></a>
        <div id="messages"></div>

        <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.0.1/socket.io.js" integrity="sha512-q/dWJ3kcmjBLU4Qc47E4A9kTB4m3wuTY7vkFJDTZKjTs8jhyGQnaUrxa0Ytd0ssMZhbNua9hE+E7Qv1j+DyZwA==" crossorigin="anonymous"></script>
        <script type="text/javascript">

        let keyPair;
        let sessionKey;
        let host = false;
        let publicKeys = [];


        let keyPairPromise = window.crypto.subtle.generateKey(
            {
                name: "RSA-OAEP",
                modulusLength: 4096,
                publicExponent: new Uint8Array([1, 0, 1]),
                hash: "SHA-256",
            },
            true,
            ["encrypt", "decrypt"],
        )

        const socket = io();
        
        socket.on('connect', async function() {
            console.log("Connecting to server");
            keyPair = await keyPairPromise
            console.log(keyPair.publicKey);
            joinRoom();
        });

        function encodeMessage64(msg) {
            let enc = new TextEncoder();
            msg = enc.encode(msg)
            return btoa(String.fromCharCode(...new Uint8Array(msg)))
        }

        function decodeMessage64(msg) {
            let dec = new TextDecoder();
            let binaryString = atob(msg); //decode from base64
            let bytes = new Uint8Array([...binaryString].map(char => char.charCodeAt(0)));
            return dec.decode(bytes);
        }


        async function joinRoom() {
            const date = new Date();
            const joinRoomMsg = {
                name : sessionStorage.getItem("displayName"),
                time : date.toLocaleTimeString('en-US'),
                publicKey : await window.crypto.subtle.exportKey('jwk', keyPair.publicKey)
            };
            const jsonJoinedRoomMsg = JSON.stringify(joinRoomMsg);
            console.log(jsonJoinedRoomMsg);
            socket.emit('joinedRoom', jsonJoinedRoomMsg);
        }

        socket.on('disconnect', function() {
            console.log("Disconnected from server");
            leaveRoom();
        });

        function leaveRoom() {
            var date = new Date();
            const leftRoomMsg = {
                name : sessionStorage.getItem("displayName"),
                time : date.toLocaleTimeString('en-US')
            };
            const jsonLeftRoomMsg = JSON.stringify(leftRoomMsg);
            socket.emit('leftRoom', jsonLeftRoomMsg);
            socket.disconnect();
        }

        const leaveButton = document.getElementById("leaveButton");
        leaveButton.addEventListener('click', leaveRoom);

        const drawButton = document.getElementById("drawButton");
        drawButton.addEventListener('click', showDrawableCanvas);

        const clearButton = document.getElementById("clearDrawing");
        clearButton.addEventListener('click', clearDrawing);


        async function generateSessionKey(){
            sessionKey = await window.crypto.subtle.generateKey(
                {
                    name: "AES-GCM",
                    length: 256,
                },
                true,
                ["encrypt", "decrypt"]
            )
        }

        //encrypt message containing session key
        async function encryptSessionKey(msg, key) {
            let ciphertext = await window.crypto.subtle.encrypt(
                {
                    name: "RSA-OAEP"
                },
                key,
                new TextEncoder().encode(msg)
            );
            return btoa(String.fromCharCode(...new Uint8Array(ciphertext))); //encode to base64
        }

        async function sendSessionKeys(){
            generateSessionKey();
            const sessionJson = {
                key: await window.crypto.subtle.exportKey('jwk', sessionKey)
            }
            console.log("SessionJson???", JSON.stringify(sessionJson));
            publicKeys.forEach(async pubKey => {
                console.log(pubKey);
                socket.emit('sendSessionKey', await encryptSessionKey(JSON.stringify(sessionJson), pubKey));
            });
        }

        //message containing session key
        async function decryptSessionKey(msg, key) {
            let binaryString = atob(msg); //decode from base64
            let bytes = new Uint8Array([...binaryString].map(char => char.charCodeAt(0)));
            let plaintext = await window.crypto.subtle.decrypt(
                {
                    name: "RSA-OAEP"
                },
                key,
                bytes
            );
            let dec = new TextDecoder;
            return dec.decode(plaintext);  
        }

        //encrypt message using session key
         async function encryptMessage(msg, key) {
            const iv = window.crypto.getRandomValues(new Uint8Array(12)); //initialization vector (needed to decrypt as well)
            const ciphertext = await window.crypto.subtle.encrypt(
                {
                    name: "AES-GCM",
                    iv
                },
                key,
                new TextEncoder().encode(msg)
            );
            return {msg : btoa(String.fromCharCode(...new Uint8Array(ciphertext))), iv};
        }

        //decrypt message using session key
        async function decryptMessage(payload, key) {
            const binaryString = atob(payload.msg); //decode from base64
            const bytes = new Uint8Array([...binaryString].map(char => char.charCodeAt(0))); //splits binaryString into individual bytes
            const iv = new Uint8Array(Object.values(payload.iv));
            const plaintext = await window.crypto.subtle.decrypt(
                {
                    name: "AES-GCM",
                    iv,
                },
                key,
                bytes
            );
            let dec = new TextDecoder;
            return dec.decode(plaintext);
        }

        async function sendMessage() {
            const messageInput = document.getElementById('messageInput');
            if(messageInput.value === "") return;
            const date = new Date();
            const message = {
                payload : await encryptMessage(messageInput.value, sessionKey),
                name : sessionStorage.getItem("displayName"),
                time : date.toLocaleTimeString('en-US')
            };
            const jsonMessage = JSON.stringify(message);
            socket.emit('message', jsonMessage);
            messageInput.value = '';
        }

        const sendButton = document.getElementById("sendButton");
        sendButton.addEventListener('click', sendMessage);

        messageInput.addEventListener('keydown', (event) => {
            if(event.key === 'Enter'){
                sendMessage();
            }
        });

        function displayMessage(message){
            var messageDiv = document.getElementById('messages');
            messageDiv.innerHTML += '<p>' + message + '</p>';
        }

        let drawableCanvas = document.getElementById("drawableCanvas");
        let canvasCTX = drawableCanvas.getContext("2d");
        let mouseDown = false;


        function showDrawableCanvas() {
            let canvasVis = drawableCanvas.style.visibility;
            let clearVis = clearButton.style.visibility;
            clearButton.style.visibility = clearVis == "visible" ? 'hidden' : "visible"
            drawableCanvas.style.visibility = canvasVis == "visible" ? 'hidden' : "visible"
        }

        function getMousePos(canvas, event){
            var rect = canvas.getBoundingClientRect();
            return {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        }

        window.addEventListener("mousedown", (event) => {
            mouseDown = true;
        })

        window.addEventListener("mouseup", (event) => {
            mouseDown = false;
        })

        function draw(event){
            let pos = getMousePos(drawableCanvas, event);
            console.log("hello from the draw function");
            if(mouseDown){
                canvasCTX.fillStyle = "#000000";
                canvasCTX.fillRect (pos.x, pos.y, 3, 3);
            }
        }

        function clearDrawing(){
            console.log("Cleared canvas");
            canvasCTX.reset();
        }
        
        function createCanvas(props={},children=[]){
            let el = document.createElement("canvas");
            Object.assign(el, props);
            el.append(...children);
            return el;
        }
        

        //debug purposes
        socket.onAny(event => {
            console.log(`got ${event}`);
        });

        socket.on("hostAssigned", (event) => {
            host = true;
            console.log("You are the host of this room.");
            generateSessionKey();
        });

        socket.on("joinedRoom", async (event) => {
            const jsonJoinedRoom = JSON.parse(event);
            console.log("New person joined room: ", jsonJoinedRoom);
            const joinedRoomString = "" + jsonJoinedRoom.time + " | " + jsonJoinedRoom.name + " has joined the room!";
            displayMessage(joinedRoomString);
            if (host) {
                pubKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    jsonJoinedRoom.publicKey, 
                    {
                        name: "RSA-OAEP",
                        hash: "SHA-256"
                    },
                    true, 
                    ['encrypt']
                );
                console.log("New public key recieved: ", pubKey);
                publicKeys.push(pubKey);
                sendSessionKeys();
            }
        });

        socket.on("nameExists", (event) => {
            alert("Name already exists in room! Please choose another name.");
            window.location.replace("../");
        });

        socket.on("leftRoom", (event) => {
            var jsonLeftRoom = JSON.parse(event);
            console.log("New person left room: ", jsonLeftRoom);
            var leftRoomString = "" + jsonLeftRoom.time + " | " + jsonLeftRoom.name + " has left the room!";
            displayMessage(leftRoomString);
        });

        socket.on('recieveSessionKey', async (event) => {
            try {
                console.log("attempting to parse: ", event);
                maybeJson = await decryptSessionKey(event, keyPair.privateKey)
                console.log("maybeJson? ", maybeJson);
                const jsonSessionKey = JSON.parse(maybeJson);
                console.log("Recieved new session key: ", jsonSessionKey);
                sessionKey = await window.crypto.subtle.importKey(
                    "jwk", 
                    jsonSessionKey.key, 
                    {
                        name: "AES-GCM",
                    },
                    true, 
                    ['encrypt','decrypt']
                );
                console.log("Session Key assigned to: ", sessionKey);
            }
            catch (exception){
                console.log(exception);
            }
        })

        socket.on("message", async (event) => {
            var jsonMessage = JSON.parse(event);
            console.log("Message from server: ", jsonMessage);
            var msgString = "" + jsonMessage.time + " | " + jsonMessage.name + ": " + await decryptMessage(jsonMessage.payload, sessionKey);
            displayMessage(msgString);
        });

        </script>
    </body>
    </html>